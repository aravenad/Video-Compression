
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>compress: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/yourorg/video-compressor/cmd/compress/root.go (100.0%)</option>
				
				<option value="file1">github.com/yourorg/video-compressor/cmd/compress/utils.go (100.0%)</option>
				
				<option value="file2">github.com/yourorg/video-compressor/internal/compressor/compressor.go (100.0%)</option>
				
				<option value="file3">github.com/yourorg/video-compressor/internal/presets/presets.go (100.0%)</option>
				
				<option value="file4">github.com/yourorg/video-compressor/internal/queue/queue.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package main implements the CLI for the video compression tool.
package main

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/spf13/cobra"

        "github.com/yourorg/video-compressor/internal/presets"
        "github.com/yourorg/video-compressor/internal/queue"
)

var (
        // Command-line flags
        output     string // Output file or directory
        parallel   int    // Number of parallel compression jobs
        presetName string // Preset name to use
        configDir  string // Directory for preset YAML files
)

func main() <span class="cov8" title="1">{
        if err := newRootCmd().Execute(); err != nil </span><span class="cov8" title="1">{
                fmt.Fprintln(os.Stderr, err)
                osExit(1)
        }</span>
}

func newRootCmd() *cobra.Command <span class="cov8" title="1">{
        root := &amp;cobra.Command{
                Use:   "video-compress",
                Short: "Video Compressor: compress videos and manage presets",
        }

        // Global config directory for presets
        root.PersistentFlags().StringVarP(&amp;configDir, "config", "c", "config/", "Directory for preset YAML files")

        // compress subcommand
        compressCmd := &amp;cobra.Command{
                Use:   "compress [flags] &lt;file1&gt; [file2…]",
                Short: "Compress one or more videos",
                Args:  cobra.MinimumNArgs(1),
                RunE:  runCompress,
        }
        compressCmd.Flags().IntVarP(&amp;parallel, "jobs", "j", 1, "Parallel compression jobs")
        compressCmd.Flags().StringVarP(&amp;output, "output", "o", "", "Output file or directory")
        compressCmd.Flags().StringVarP(&amp;presetName, "preset", "p", "default", "Preset name to use")
        // preset overrides
        compressCmd.Flags().String("video-codec", "", "Override video codec from preset")
        compressCmd.Flags().String("ffpreset", "", "Override ffmpeg preset from preset")
        compressCmd.Flags().Int("crf", -1, "Override CRF value from preset")

        root.AddCommand(compressCmd)
        root.AddCommand(newPresetsCmd())
        return root
}</span>

func runCompress(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // Set config file path
        presets.ConfigFile = filepath.Join(configDir, "default.yaml")

        // 1. Load presets
        all, err := loadPresetsFunc()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("loading presets from %s: %w", presets.ConfigFile, err)
        }</span>
        <span class="cov8" title="1">p, ok := all[presetName]
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("unknown preset %q; available: %v", presetName, presets.ListNames(all))
        }</span>

        // 2. Apply overrides
        <span class="cov8" title="1">if vc := mustGetString(cmd, "video-codec"); vc != "" </span><span class="cov8" title="1">{
                p.VideoCodec = vc
        }</span>
        <span class="cov8" title="1">if pf := mustGetString(cmd, "ffpreset"); pf != "" </span><span class="cov8" title="1">{
                p.Preset = pf
        }</span>
        <span class="cov8" title="1">if crf := mustGetInt(cmd, "crf"); crf &gt;= 0 </span><span class="cov8" title="1">{
                p.CRF = crf
        }</span>

        // 3. Build ffmpeg args
        <span class="cov8" title="1">ffArgs := presets.BuildFFArgs(p)

        // 4. Initialize queue
        q := queue.New(parallel)

        // 5. Enqueue tasks
        for _, in := range args </span><span class="cov8" title="1">{
                dest := deriveOutput(in, output)
                q.Add(queue.Task{Source: in, Destination: dest, Args: ffArgs})
        }</span>

        // 6. Run queue
        <span class="cov8" title="1">results := q.Run()

        // 7. Summarize
        successes, failures := 0, 0
        for _, r := range results </span><span class="cov8" title="1">{
                if r.Err != nil </span><span class="cov8" title="1">{
                        fmt.Fprintf(os.Stderr, "Error compressing %s: %v\n", r.Task.Source, r.Err)
                        failures++
                }</span> else<span class="cov8" title="1"> {
                        cmd.Println("✓", r.Task.Source)
                        successes++
                }</span>
        }
        <span class="cov8" title="1">if failures &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("one or more files failed to compress")
        }</span>
        <span class="cov8" title="1">cmd.Println("All done!")
        return nil</span>
}

func newPresetsCmd() *cobra.Command <span class="cov8" title="1">{
        pcmd := &amp;cobra.Command{
                Use:   "presets",
                Short: "Manage compression presets",
        }

        // Ensure using the correct config file
        pcmd.PersistentPreRun = func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                presets.ConfigFile = filepath.Join(configDir, "default.yaml")
        }</span>

        // list
        <span class="cov8" title="1">pcmd.AddCommand(&amp;cobra.Command{
                Use:   "list",
                Short: "List all presets",
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov8" title="1">{
                        all, err := loadPresetsFunc()
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("loading presets from %s: %w", presets.ConfigFile, err)
                        }</span>
                        <span class="cov8" title="1">for _, name := range presets.ListNames(all) </span><span class="cov8" title="1">{
                                cmd.Println(name)
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                },
        })

        // add
        <span class="cov8" title="1">add := &amp;cobra.Command{
                Use:   "add &lt;name&gt;",
                Short: "Add or overwrite a preset",
                Args: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                        if len(args) != 1 </span><span class="cov8" title="1">{
                                return fmt.Errorf("requires exactly 1 arg")
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                },
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                        p := presets.Preset{
                                VideoCodec: mustGetString(cmd, "video-codec"),
                                Preset:     mustGetString(cmd, "preset"),
                                CRF:        mustGetInt(cmd, "crf"),
                        }
                        if err := savePresetFunc(args[0], p); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("saving preset %s: %w", args[0], err)
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                },
        }
        <span class="cov8" title="1">add.Flags().String("video-codec", "libx264", "ffmpeg video codec")
        add.Flags().String("preset", "medium", "ffmpeg preset")
        add.Flags().Int("crf", 23, "ffmpeg CRF value")
        pcmd.AddCommand(add)

        // remove
        rm := &amp;cobra.Command{
                Use:   "remove &lt;name&gt;",
                Short: "Delete a named preset",
                Args: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                        if len(args) != 1 </span><span class="cov8" title="1">{
                                return fmt.Errorf("requires exactly 1 arg")
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                },
                RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                        if err := deletePresetFunc(args[0]); err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("deleting preset %s: %w", args[0], err)
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                },
        }
        <span class="cov8" title="1">pcmd.AddCommand(rm)

        return pcmd</span>
}

// mustGetString retrieves a string flag or panics
func mustGetString(cmd *cobra.Command, name string) string <span class="cov8" title="1">{
        s, err := cmd.Flags().GetString(name)
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return s</span>
}

// mustGetInt retrieves an int flag or panics
func mustGetInt(cmd *cobra.Command, name string) int <span class="cov8" title="1">{
        i, err := cmd.Flags().GetInt(name)
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return i</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// This file contains utility functions for the compress command.
package main

import (
        "os"
        "path/filepath"
        "strings"
)

// deriveOutput returns the output file path for a given input file.
// Behavior:
//  1. If output == "": place alongside the input file, appending "-compressed" to the basename.
//  2. If output exists and is a directory, place the file inside it, keeping the same basename.
//  3. If output ends with a path separator, treat it as a directory.
//  4. Otherwise, treat output as the explicit file path.
//
// Examples:
//   - deriveOutput("video.mp4", "") -&gt; "video-compressed.mp4" (in same directory)
//   - deriveOutput("video.mp4", "out/") -&gt; "out/video.mp4"
//   - deriveOutput("video.mp4", "renamed.mp4") -&gt; "renamed.mp4"
func deriveOutput(infile, output string) string <span class="cov8" title="1">{
        if output == "" </span><span class="cov8" title="1">{
                dir := filepath.Dir(infile)
                ext := filepath.Ext(infile)
                name := strings.TrimSuffix(filepath.Base(infile), ext)
                return filepath.Join(dir, name+"-compressed"+ext)
        }</span>
        <span class="cov8" title="1">if info, err := os.Stat(output); err == nil &amp;&amp; info.IsDir() </span><span class="cov8" title="1">{
                return filepath.Join(output, filepath.Base(infile))
        }</span>
        <span class="cov8" title="1">if strings.HasSuffix(output, string(os.PathSeparator)) || strings.HasSuffix(output, "/") </span><span class="cov8" title="1">{
                return filepath.Join(output, filepath.Base(infile))
        }</span>
        <span class="cov8" title="1">return output</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package compressor provides video compression functionality by invoking
// external ffmpeg processes with appropriate arguments.
package compressor

import (
        "fmt"
        "os/exec"
)

// Compress invokes ffmpeg with args based on the preset.
// Parameters:
//   - input: path to input video file
//   - output: path where output will be written
//   - args: additional ffmpeg arguments, typically from presets.BuildFFArgs
//
// Returns an error if ffmpeg execution fails.
func Compress(input, output string, args []string) error <span class="cov8" title="1">{
        fullArgs := []string{"-i", input}
        fullArgs = append(fullArgs, args...)
        fullArgs = append(fullArgs, output)

        fmt.Printf("Running: ffmpeg %v\n", fullArgs)
        cmd := exec.Command("ffmpeg", fullArgs...)
        cmd.Stdout = nil
        cmd.Stderr = nil
        return cmd.Run()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package presets provides functionality for managing ffmpeg encoding presets
// stored in YAML configuration files.
package presets

import (
        "fmt"
        "os"
        "sort"

        "path/filepath"

        "gopkg.in/yaml.v3"
)

var (
        // ConfigFile is the path to the YAML file with presets.
        ConfigFile = "config/default.yaml"

        // yamlMarshal is a variable to allow mocking in tests
        yamlMarshal = yaml.Marshal
)

// Preset holds all the ffmpeg settings for one named preset.
// The Name field is not stored in YAML but populated from the map key.
type Preset struct {
        Name       string `yaml:"-"`
        VideoCodec string `mapstructure:"video_codec" yaml:"video_codec"`
        CRF        int    `mapstructure:"crf"           yaml:"crf"`
        Preset     string `mapstructure:"preset"        yaml:"preset"`
}

// LoadAll reads ConfigFile directly and unmarshals into a map of Presets.
// Returns error if the file cannot be read or parsed.
func LoadAll() (map[string]Preset, error) <span class="cov8" title="1">{
        // 1. Read the YAML file (may be test-overridden via ConfigFile)
        data, err := os.ReadFile(ConfigFile)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("reading presets config: %w", err)
        }</span>

        // 2. Unmarshal into an aux struct
        <span class="cov8" title="1">aux := struct {
                Presets map[string]Preset `yaml:"presets"`
        }{}
        if err := yaml.Unmarshal(data, &amp;aux); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("parsing presets config: %w", err)
        }</span>

        // 3. Wire up Name fields
        <span class="cov8" title="1">for name, p := range aux.Presets </span><span class="cov8" title="1">{
                p.Name = name
                aux.Presets[name] = p
        }</span>

        <span class="cov8" title="1">return aux.Presets, nil</span>
}

// BuildFFArgs turns a Preset into ffmpeg CLI args (minus input/output).
// Returns a slice of strings suitable for passing to exec.Command.
func BuildFFArgs(p Preset) []string <span class="cov8" title="1">{
        return []string{
                "-c:v", p.VideoCodec,
                "-preset", p.Preset,
                "-crf", fmt.Sprintf("%d", p.CRF),
        }
}</span>

// Save writes or overwrites the preset named name to the config file.
// Creates the config file and directories if they don't exist.
func Save(name string, p Preset) error <span class="cov8" title="1">{
        // 1. Read existing file (or start fresh)
        cfg := struct {
                Presets map[string]Preset `yaml:"presets"`
        }{}
        data, err := os.ReadFile(ConfigFile)
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov8" title="1">{
                return fmt.Errorf("reading config: %w", err)
        }</span>
        <span class="cov8" title="1">if len(data) &gt; 0 </span><span class="cov8" title="1">{
                if err := yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("parsing config: %w", err)
                }</span>
        }
        <span class="cov8" title="1">if cfg.Presets == nil </span><span class="cov8" title="1">{
                cfg.Presets = make(map[string]Preset)
        }</span>

        // 2. Insert or overwrite
        <span class="cov8" title="1">p.Name = name
        cfg.Presets[name] = p

        // 3. Write back
        out, err := yamlMarshal(&amp;cfg)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("serializing config: %w", err)
        }</span>
        <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(ConfigFile), 0o755); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("creating config dir: %w", err)
        }</span>
        <span class="cov8" title="1">if err := os.WriteFile(ConfigFile, out, 0o644); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("writing config: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Delete removes the named preset from the config file.
// Returns error if the file doesn't exist or cannot be modified.
func Delete(name string) error <span class="cov8" title="1">{
        cfg := struct {
                Presets map[string]Preset `yaml:"presets"`
        }{}
        data, err := os.ReadFile(ConfigFile)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("reading config: %w", err)
        }</span>
        <span class="cov8" title="1">if err := yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("parsing config: %w", err)
        }</span>
        <span class="cov8" title="1">delete(cfg.Presets, name)

        out, err := yamlMarshal(&amp;cfg)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("serializing config: %w", err)
        }</span>
        <span class="cov8" title="1">if err := os.WriteFile(ConfigFile, out, 0o644); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("writing config: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ListNames returns the sorted list of preset names.
// This ensures consistent ordering for display purposes.
func ListNames(all map[string]Preset) []string <span class="cov8" title="1">{
        names := make([]string, 0, len(all))
        for n := range all </span><span class="cov8" title="1">{
                names = append(names, n)
        }</span>
        <span class="cov8" title="1">sort.Strings(names)
        return names</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package queue

import (
        "sync"

        "github.com/yourorg/video-compressor/internal/compressor"
)

// Task represents one compression job, including the ffmpeg arguments to use.
type Task struct {
        Source      string   // input path
        Destination string   // output path
        Args        []string // ffmpeg args (e.g. from presets.BuildFFArgs)
}

// Result holds the outcome of a Task.
type Result struct {
        Task Task
        Err  error
}

// Queue manages and runs tasks concurrently.
type Queue struct {
        tasks       []Task
        concurrency int
}

// Define a variable for the compress function to allow mocking in tests
var compressFunc = compressor.Compress

// GetCompressFunc returns the current compressFunc - useful for testing
func GetCompressFunc() func(string, string, []string) error <span class="cov8" title="1">{
        return compressFunc
}</span>

// SetCompressFunc replaces the current compressFunc - useful for testing
func SetCompressFunc(fn func(string, string, []string) error) <span class="cov8" title="1">{
        compressFunc = fn
}</span>

// New creates a Queue with a given concurrency level.
func New(concurrency int) *Queue <span class="cov8" title="1">{
        return &amp;Queue{
                concurrency: concurrency,
                tasks:       make([]Task, 0),
        }
}</span>

// Add enqueues a Task.
func (q *Queue) Add(task Task) <span class="cov8" title="1">{
        q.tasks = append(q.tasks, task)
}</span>

// Run processes all queued tasks and blocks until done.
// It returns a slice of Results corresponding to each Task.
func (q *Queue) Run() []Result <span class="cov8" title="1">{
        taskChan := make(chan Task)
        resultChan := make(chan Result)
        var wg sync.WaitGroup

        // Start worker goroutines
        for i := 0; i &lt; q.concurrency; i++ </span><span class="cov8" title="1">{
                wg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer wg.Done()
                        for task := range taskChan </span><span class="cov8" title="1">{
                                err := compressFunc(task.Source, task.Destination, task.Args)
                                resultChan &lt;- Result{Task: task, Err: err}
                        }</span>
                }()
        }

        // Feed tasks into taskChan
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                for _, task := range q.tasks </span><span class="cov8" title="1">{
                        taskChan &lt;- task
                }</span>
                <span class="cov8" title="1">close(taskChan)</span>
        }()

        // Close resultChan once all workers are done
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(resultChan)
        }</span>()

        // Collect results
        <span class="cov8" title="1">results := make([]Result, 0, len(q.tasks))
        for res := range resultChan </span><span class="cov8" title="1">{
                results = append(results, res)
        }</span>

        <span class="cov8" title="1">return results</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
