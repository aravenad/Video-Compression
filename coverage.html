
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>compress: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/yourorg/video-compressor/cmd/compress/root.go (92.9%)</option>
				
				<option value="file1">github.com/yourorg/video-compressor/cmd/compress/utils.go (90.0%)</option>
				
				<option value="file2">github.com/yourorg/video-compressor/internal/compressor/compressor.go (100.0%)</option>
				
				<option value="file3">github.com/yourorg/video-compressor/internal/presets/presets.go (84.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"

        "github.com/yourorg/video-compressor/internal/presets"
)

// global flags
var (
        output   string
        preset   string
        parallel int
)

// newRootCmd builds (but does not execute) the CLI command.
func newRootCmd() *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "compress [flags] &lt;file1&gt; [file2] [...]",
                Short: "Video compressor CLI",
                Long:  "A fast, single-binary Go CLI for cross-platform video compression.",
                Args:  cobra.MinimumNArgs(1),
                RunE:  runCompress,
        }

        cmd.Flags().StringVarP(&amp;output, "output", "o", "", "Output file or directory")
        cmd.Flags().StringVarP(&amp;preset, "preset", "p", "default", "Compression preset name")
        cmd.Flags().IntVarP(&amp;parallel, "jobs", "j", 1, "Number of parallel jobs")
        viper.BindPFlag("preset", cmd.Flags().Lookup("preset"))

        return cmd
}</span>

func main() <span class="cov0" title="0">{
        if err := newRootCmd().Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, err)
                os.Exit(1)
        }</span>
}

func runCompress(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // 1. Load presets via the hookable func
        allPresets, err := loadPresetsFunc()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("loading presets: %w", err)
        }</span>
        <span class="cov8" title="1">p, ok := allPresets[preset]
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("unknown preset %q; available: %v", preset, keys(allPresets))
        }</span>

        // 2. Build ffmpeg args
        <span class="cov8" title="1">ffArgs := presets.BuildFFArgs(p)

        // 3. Concurrency
        sem := make(chan struct{}, parallel)
        errs := make(chan error, len(args))
        for _, infile := range args </span><span class="cov8" title="1">{
                sem &lt;- struct{}{}
                go func(in string) </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{ &lt;-sem }</span>()
                        <span class="cov8" title="1">out := deriveOutput(in, output)
                        if err := compressFunc(in, out, ffArgs); err != nil </span><span class="cov8" title="1">{
                                errs &lt;- fmt.Errorf("%s: %w", in, err)
                                return
                        }</span>
                        // Report success into Cobra’s output writer
                        <span class="cov8" title="1">cmd.Println("✓", in)
                        errs &lt;- nil</span>
                }(infile)
        }

        // 4. Wait &amp; report
        <span class="cov8" title="1">var failed bool
        for i := 0; i &lt; len(args); i++ </span><span class="cov8" title="1">{
                if err := &lt;-errs; err != nil </span><span class="cov8" title="1">{
                        // Send errors to the command’s error writer
                        fmt.Fprintln(cmd.ErrOrStderr(), err)
                        failed = true
                }</span>
        }
        <span class="cov8" title="1">if failed </span><span class="cov8" title="1">{
                return fmt.Errorf("one or more files failed to compress")
        }</span>

        // Final success message via Cobra
        <span class="cov8" title="1">cmd.Println("All done!")
        return nil</span>
}

// keys as before...
func keys(m map[string]presets.Preset) []string <span class="cov8" title="1">{
        ks := make([]string, 0, len(m))
        for k := range m </span><span class="cov8" title="1">{
                ks = append(ks, k)
        }</span>
        <span class="cov8" title="1">return ks</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "os"
        "path/filepath"
        "strings"
)

// deriveOutput returns the output file path for a given input file.
// Behavior:
// 1. If output == "": place alongside the input file, appending "-compressed" to the basename.
// 2. If output exists and is a directory, place the file inside it, keeping the same basename.
// 3. If output ends with a path separator, treat it as a directory.
// 4. Otherwise, treat output as the explicit file path.
func deriveOutput(infile, output string) string <span class="cov8" title="1">{
        // 1. No output provided: generate alongside infile
        if output == "" </span><span class="cov8" title="1">{
                dir := filepath.Dir(infile)
                ext := filepath.Ext(infile)
                name := strings.TrimSuffix(filepath.Base(infile), ext)
                return filepath.Join(dir, name+"-compressed"+ext)
        }</span>

        // 2. If it's an existing directory, drop file inside
        <span class="cov8" title="1">if info, err := os.Stat(output); err == nil &amp;&amp; info.IsDir() </span><span class="cov8" title="1">{
                return filepath.Join(output, filepath.Base(infile))
        }</span>

        // 3. If it ends with a slash, treat as directory (even if not existing yet)
        <span class="cov8" title="1">if strings.HasSuffix(output, string(os.PathSeparator)) </span><span class="cov0" title="0">{
                return filepath.Join(output, filepath.Base(infile))
        }</span>

        // 4. Otherwise, use exact output path
        <span class="cov8" title="1">return output</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package compressor

import (
        "fmt"
        "os/exec"
)

// Compress invokes ffmpeg with args based on the preset.
func Compress(input, output string, args []string) error <span class="cov8" title="1">{
        fullArgs := []string{"-i", input}
        fullArgs = append(fullArgs, args...)
        fullArgs = append(fullArgs, output)

        fmt.Printf("Running: ffmpeg %v\n", fullArgs)
        cmd := exec.Command("ffmpeg", fullArgs...)
        cmd.Stdout = nil
        cmd.Stderr = nil
        return cmd.Run()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package presets

import (
        "fmt"

        "github.com/spf13/viper"
)

// Preset holds all the ffmpeg settings for one named preset.
type Preset struct {
        Name       string
        VideoCodec string `mapstructure:"video_codec"`
        CRF        int    `mapstructure:"crf"`
        Preset     string `mapstructure:"preset"` // e.g. “medium”, “fast”
}

// LoadAll reads config/default.yaml into Viper and unmarshals into a map of Presets.
// It searches for the config file in "config/", "../config/", and "../../config/" to support tests.
func LoadAll() (map[string]Preset, error) <span class="cov8" title="1">{
        viper.SetConfigName("default")
        // Search project config directory when running at root
        viper.AddConfigPath("config")
        // Support tests running from internal/presets
        viper.AddConfigPath("../config")
        // Support tests running from internal/presets subdir on different CWD
        viper.AddConfigPath("../../config")

        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reading presets config: %w", err)
        }</span>

        <span class="cov8" title="1">raw := viper.GetStringMap("presets")
        result := make(map[string]Preset, len(raw))

        for name := range raw </span><span class="cov8" title="1">{
                sub := viper.Sub("presets." + name)
                if sub == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">var p Preset
                if err := sub.Unmarshal(&amp;p); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unmarshal preset %q: %w", name, err)
                }</span>
                <span class="cov8" title="1">p.Name = name
                result[name] = p</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

// BuildFFArgs turns a Preset into ffmpeg CLI args (minus input/output).
func BuildFFArgs(p Preset) []string <span class="cov8" title="1">{
        return []string{
                "-c:v", p.VideoCodec,
                "-preset", p.Preset,
                "-crf", fmt.Sprintf("%d", p.CRF),
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
